<!DOCTYPE html>
<html>
<head>
    <title>Pixel FPS Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            overflow: hidden;
        }
        
        #gameCanvas {
            background: #111;
            image-rendering: pixelated;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            z-index: 10;
        }
        
        #crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            transform: translate(-50%, -50%);
        }
        
        .pixel {
            position: absolute;
            background: white;
        }
        
        .player {
            background: #4A90E2;
        }
        
        .enemy {
            background: #E74C3C;
        }
        
        .bullet {
            background: yellow;
            border-radius: 50%;
        }
        
        #gameNote {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 15;
        }

        /* Mobile controls (hidden by default) */
        #joystick {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: none;
            touch-action: none;
            z-index: 25;
        }
        #joystickKnob {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 60px;
            height: 60px;
            margin-left: -30px;
            margin-top: -30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.35);
            pointer-events: none;
        }
        #fireButton {
            position: absolute;
            right: 20px;
            bottom: 40px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: rgba(255, 87, 34, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.35);
            color: white;
            font-size: 16px;
            display: none;
            touch-action: none;
            z-index: 25;
            user-select: none;
        }
        #fireButton:active {
            background: rgba(255, 87, 34, 0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">Health: <span id="health">100</span> | Score: <span id="score">0</span> | Stage: <span id="stage">1</span></div>
        <div id="crosshair"></div>
        <button id="startButton" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; font-size: 24px; z-index: 20; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 5px;">Start Game</button>
        <button id="recallButton" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; display: none; z-index: 20; cursor: pointer; background: #FF5722; color: white; border: none; border-radius: 5px;">Recall</button>
        
        <!-- Mobile controls -->
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
        <button id="fireButton">FIRE</button>
        
        <!-- Small game note -->
        <div id="gameNote">
            Use WASD/Arrow keys to move<br>
            Click mouse to shoot<br>
            Triple Shot → +30 Health → Full Health every 20s
        </div>
    </div>

    <!-- Game over modal -->
    <div id="gameOverModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center; display: none;">
        <div style="background: #333; padding: 20px; border-radius: 10px; text-align: center;">
            <h2 id="finalScoreMessage" style="color: white;"></h2>
            <button id="restartButton" style="padding: 10px 20px; font-size: 18px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 10px;">Restart Game</button>
        </div>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const healthDisplay = document.getElementById('health');
        const scoreDisplay = document.getElementById('score');
        const stageDisplay = document.getElementById('stage');
        const crosshair = document.getElementById('crosshair');
        const container = document.getElementById('gameContainer');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreMessage = document.getElementById('finalScoreMessage');
        
        // Get buttons only after they exist in DOM
        const startButton = document.getElementById('startButton');
        const recallButton = document.getElementById('recallButton');
        const restartButton = document.getElementById('restartButton');
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');
        const fireButton = document.getElementById('fireButton');
        const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        
        // Item types
        const ITEM_TYPES = {
            TRIPLE_SHOT: 1,
            HEALTH_30: 2,
            HEALTH_FULL: 3
        };
        
        // Game state
        const stageThresholds = [0, 200, 400, 800, 1000]; // Stage thresholds
        const maxEnemiesPerStage = [5, 8, 12, 15, 20]; // Max enemies per stage
        let currentStage = 1;
        let enemiesSpawnedThisStage = 0;
        
        const gameState = {
            player: {
                x: 400,
                y: 300,
                width: 20,
                height: 20,
                speed: 3,
                health: 100,
                score: 0
            },
            enemies: [],
            bullets: [],
            items: [],          // Array for collectible items
            explosions: [],      // Array for explosion effects
            deathExplosion: {    // NEW: Death explosion particles
                active: false,
                particles: [],
                maxParticles: 50
            },
            keys: {},
            mouse: { x: 0, y: 0, clicked: false },
            lastEnemySpawn: 0,
            enemySpawnRate: 1000, // ms
            gameOver: false,
            finished: false,
            tripleShotActive: false,  // Triple shot status
            tripleShotEndTime: 0,     // Triple shot timer
            nextItemTime: 0,          // Time for next item spawn
            currentItemIndex: 0,      // Current item in sequence (0,1,2)
            itemSpawnInterval: 20000, // 20 seconds between items
            screenShake: {            // NEW: Screen shake system
                active: false,
                intensity: 0,
                duration: 0,
                maxIntensity: 0,
                time: 0
            },
            hitEffect: {              // NEW: Hit effect
                active: false,
                time: 0,
                maxTime: 200
            }
        };

        // Initialize game as not started
        let gameStarted = false;
        let baseContainerPosition = { x: 0, y: 0 };

        // Mobile control state
        const mobile = {
            joystickActive: false,
            joyCenter: { x: 0, y: 0 },
            joyValue: { x: 0, y: 0 },
            fireInterval: null,
            firing: false
        };

        // Create enemies
        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = Math.random() * canvas.width;
                    y = -20;
                    break;
                case 1: // right
                    x = canvas.width + 20;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 20;
                    break;
                case 3: // left
                    x = -20;
                    y = Math.random() * canvas.height;
                    break;
            }
            
            gameState.enemies.push({
                x: x,
                y: y,
                width: 16,
                height: 16,
                speed: 1 + Math.random() * 1.5,
                health: 30
            });
        }
        
        // NEW: Create death explosion particles
        function createDeathExplosion(x, y) {
            gameState.deathExplosion.active = true;
            gameState.deathExplosion.particles = [];
            
            for (let i = 0; i < gameState.deathExplosion.maxParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 5;
                const size = 2 + Math.random() * 4;
                const hue = Math.random() * 60; // Orange/red colors
                
                gameState.deathExplosion.particles.push({
                    x: x,
                    y: y,
                    size: size,
                    speedX: Math.cos(angle) * speed,
                    speedY: Math.sin(angle) * speed,
                    alpha: 1,
                    color: `hsl(${hue}, 100%, 50%)`
                });
            }
        }
        
        // NEW: Create hit effect (screen shake + red flash)
        function createHitEffect() {
            gameState.hitEffect.active = true;
            gameState.hitEffect.time = Date.now();
            
            // Screen shake for hit
            gameState.screenShake.active = true;
            gameState.screenShake.intensity = 3;
            gameState.screenShake.maxIntensity = 3;
            gameState.screenShake.duration = 100;
            gameState.screenShake.time = Date.now();
        }
        
        // NEW: Create enemy kill screen shake
        function createEnemyKillShake() {
            gameState.screenShake.active = true;
            gameState.screenShake.intensity = 1.5;
            gameState.screenShake.maxIntensity = 1.5;
            gameState.screenShake.duration = 80;
            gameState.screenShake.time = Date.now();
        }

        // Fire bullet
        function fireBullet() {
            const angle = Math.atan2(
                gameState.mouse.y - gameState.player.y,
                gameState.mouse.x - gameState.player.x
            );
            
            // Triple shot logic (now 5 seconds duration)
            if (gameState.tripleShotActive) {
                // Fire three bullets in a spread
                const spread = 0.2; // about 11 degrees in radians
                for (let i = -1; i <= 1; i++) {
                    const bulletAngle = angle + i * spread;
                    gameState.bullets.push({
                        x: gameState.player.x,
                        y: gameState.player.y,
                        width: 4,
                        height: 4,
                        speed: 7,
                        dx: Math.cos(bulletAngle),
                        dy: Math.sin(bulletAngle)
                    });
                }
            } else {
                gameState.bullets.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    width: 4,
                    height: 4,
                    speed: 7,
                    dx: Math.cos(angle),
                    dy: Math.sin(angle)
                });
            }
        }

        // Update game objects
        function update() {
            if (gameState.gameOver) {
                return;
            }
            // Player movement (keyboard + mobile joystick)
            let moveX = 0, moveY = 0;
            if (gameState.keys['w'] || gameState.keys['ArrowUp']) moveY -= 1;
            if (gameState.keys['s'] || gameState.keys['ArrowDown']) moveY += 1;
            if (gameState.keys['a'] || gameState.keys['ArrowLeft']) moveX -= 1;
            if (gameState.keys['d'] || gameState.keys['ArrowRight']) moveX += 1;
            // Apply joystick vector
            if (Math.abs(mobile.joyValue.x) > 0.01 || Math.abs(mobile.joyValue.y) > 0.01) {
                moveX += mobile.joyValue.x;
                moveY += mobile.joyValue.y;
            }
            // Normalize to prevent diagonal speed boost
            if (moveX !== 0 || moveY !== 0) {
                const len = Math.hypot(moveX, moveY) || 1;
                gameState.player.x += (moveX / len) * gameState.player.speed;
                gameState.player.y += (moveY / len) * gameState.player.speed;
            }
            
            // Keep player in bounds
            gameState.player.x = Math.max(0, Math.min(canvas.width - gameState.player.width, gameState.player.x));
            gameState.player.y = Math.max(0, Math.min(canvas.height - gameState.player.height, gameState.player.y));
            
            // Spawn enemies
            const now = Date.now();
            if (now - gameState.lastEnemySpawn > gameState.enemySpawnRate) {
                if (enemiesSpawnedThisStage < maxEnemiesPerStage[currentStage - 1]) {
                    spawnEnemy();
                    enemiesSpawnedThisStage++;
                }
                gameState.lastEnemySpawn = now;
            }
            
            // Move enemies towards player
            gameState.enemies.forEach(enemy => {
                const angle = Math.atan2(
                    gameState.player.y - enemy.y,
                    gameState.player.x - enemy.x
                );
                
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;
                
                // Collision with player
                if (
                    gameState.player.x < enemy.x + enemy.width &&
                    gameState.player.x + gameState.player.width > enemy.x &&
                    gameState.player.y < enemy.y + enemy.height &&
                    gameState.player.y + gameState.player.height > enemy.y
                ) {
                    gameState.player.health -= 0.5;
                    healthDisplay.textContent = Math.max(0, Math.floor(gameState.player.health));
                    
                    // NEW: Create hit effect
                    createHitEffect();
                }
            });
            
            // Move bullets
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                bullet.x += bullet.dx * bullet.speed;
                bullet.y += bullet.dy * bullet.speed;
                
                // Remove bullets that go off-screen
                if (
                    bullet.x < 0 || 
                    bullet.x > canvas.width || 
                    bullet.y < 0 || 
                    bullet.y > canvas.height
                ) {
                    gameState.bullets.splice(i, 1);
                    continue;
                }
                
                // Bullet-enemy collision
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y
                    ) {
                        enemy.health -= 15;
                        gameState.bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            // NEW: Create explosion effect
                            gameState.explosions.push({
                                x: enemy.x + enemy.width/2,
                                y: enemy.y + enemy.height/2,
                                radius: 0,
                                maxRadius: 30,
                                speed: 2
                            });
                            
                            // NEW: Create enemy kill screen shake
                            createEnemyKillShake();
                            
                            gameState.enemies.splice(j, 1);
                            gameState.player.score += 10;
                            scoreDisplay.textContent = gameState.player.score;
                            enemiesSpawnedThisStage--;
                            if (gameState.player.score >= stageThresholds[currentStage]) {
                                currentStage++;
                                stageDisplay.textContent = currentStage;
                                enemiesSpawnedThisStage = 0;
                            }
                        }
                        break;
                    }
                }
            }
            
            // Update explosions
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.radius += explosion.speed;
                if (explosion.radius > explosion.maxRadius) {
                    gameState.explosions.splice(i, 1);
                }
            }
            
            // NEW: Update death explosion particles
            if (gameState.deathExplosion.active) {
                for (let i = gameState.deathExplosion.particles.length - 1; i >= 0; i--) {
                    const p = gameState.deathExplosion.particles[i];
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.alpha -= 0.02;
                    p.size *= 0.96;
                    
                    if (p.alpha <= 0 || p.size <= 0.5) {
                        gameState.deathExplosion.particles.splice(i, 1);
                    }
                }
                
                if (gameState.deathExplosion.particles.length === 0) {
                    gameState.deathExplosion.active = false;
                }
            }
            
            // NEW: Update screen shake
            if (gameState.screenShake.active) {
                const elapsed = now - gameState.screenShake.time;
                if (elapsed > gameState.screenShake.duration) {
                    gameState.screenShake.active = false;
                } else {
                    const progress = elapsed / gameState.screenShake.duration;
                    gameState.screenShake.intensity = gameState.screenShake.maxIntensity * (1 - progress);
                }
            }
            
            // NEW: Update hit effect
            if (gameState.hitEffect.active) {
                if (now - gameState.hitEffect.time > gameState.hitEffect.maxTime) {
                    gameState.hitEffect.active = false;
                }
            }
            
            // Timed item spawning (every 20 seconds in sequence)
            if (gameStarted && now >= gameState.nextItemTime) {
                // Determine which item to spawn based on current index
                let itemType;
                switch(gameState.currentItemIndex) {
                    case 0:
                        itemType = ITEM_TYPES.TRIPLE_SHOT;
                        break;
                    case 1:
                        itemType = ITEM_TYPES.HEALTH_30;
                        break;
                    case 2:
                        itemType = ITEM_TYPES.HEALTH_FULL;
                        break;
                }
                
                // Spawn item at random position
                const x = Math.random() * (canvas.width - 16);
                const y = Math.random() * (canvas.height - 16);
                gameState.items.push({
                    x: x,
                    y: y,
                    width: 16,
                    height: 16,
                    type: itemType,
                    createdAt: now
                });
                
                // Update for next item
                gameState.currentItemIndex = (gameState.currentItemIndex + 1) % 3;
                gameState.nextItemTime = now + gameState.itemSpawnInterval;
            }
            
            // Check item collisions
            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const item = gameState.items[i];
                
                // Remove items that have been on screen too long
                if (now - item.createdAt > 8000) {
                    gameState.items.splice(i, 1);
                    continue;
                }
                
                if (
                    gameState.player.x < item.x + item.width &&
                    gameState.player.x + gameState.player.width > item.x &&
                    gameState.player.y < item.y + item.height &&
                    gameState.player.y + gameState.player.height > item.y
                ) {
                    // Collect item
                    if (item.type === ITEM_TYPES.TRIPLE_SHOT) {
                        gameState.tripleShotActive = true;
                        gameState.tripleShotEndTime = Date.now() + 5000; // 5 seconds only
                    } else if (item.type === ITEM_TYPES.HEALTH_30) {
                        gameState.player.health = Math.min(100, gameState.player.health + 30);
                        healthDisplay.textContent = Math.floor(gameState.player.health);
                    } else if (item.type === ITEM_TYPES.HEALTH_FULL) {
                        gameState.player.health = 100;
                        healthDisplay.textContent = '100';
                    }
                    gameState.items.splice(i, 1);
                }
            }
            
            // Check if triple shot has expired
            if (gameState.tripleShotActive && Date.now() > gameState.tripleShotEndTime) {
                gameState.tripleShotActive = false;
            }
            
            // Remove dead enemies
            gameState.enemies = gameState.enemies.filter(enemy => enemy.health > 0);
            
            // Check game over
            if (gameState.player.health <= 0 && !gameState.gameOver) {
                // NEW: Create death explosion at player position
                createDeathExplosion(gameState.player.x + 10, gameState.player.y + 10);
                
                finalScoreMessage.textContent = `Game Over! Final Score: ${gameState.player.score}`;
                gameOverModal.style.display = 'flex';
                gameState.gameOver = true;
                return;
            }
            
            // Show recall button when health is 1
            if (gameState.player.health === 1) {
                recallButton.style.display = 'block';
            } else {
                recallButton.style.display = 'none';
            }
        }

        // NEW: Apply screen shake to container
        function applyScreenShake() {
            if (gameState.screenShake.active) {
                const shakeX = (Math.random() - 0.5) * gameState.screenShake.intensity * 2;
                const shakeY = (Math.random() - 0.5) * gameState.screenShake.intensity * 2;
                container.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            } else {
                container.style.transform = 'translate(0, 0)';
            }
        }

        // Draw everything
        function render() {
            // Apply screen shake
            applyScreenShake();
            
            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // NEW: Draw hit effect (red flash)
            if (gameState.hitEffect.active) {
                const elapsed = Date.now() - gameState.hitEffect.time;
                const intensity = 0.5 * (1 - elapsed / gameState.hitEffect.maxTime);
                ctx.fillStyle = `rgba(255, 0, 0, ${intensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw player
            ctx.fillStyle = '#4A90E2';
            ctx.fillRect(
                gameState.player.x, 
                gameState.player.y, 
                gameState.player.width, 
                gameState.player.height
            );
            
            // Draw enemies
            ctx.fillStyle = '#E74C3C';
            gameState.enemies.forEach(enemy => {
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            });
            
            // Draw bullets
            ctx.fillStyle = 'yellow';
            gameState.bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            
            // Draw items
            gameState.items.forEach(item => {
                if (item.type === ITEM_TYPES.TRIPLE_SHOT) {
                    ctx.fillStyle = '#4CAF50'; // green
                } else if (item.type === ITEM_TYPES.HEALTH_30) {
                    ctx.fillStyle = '#2196F3'; // blue
                } else {
                    ctx.fillStyle = '#FF5722'; // orange
                }
                ctx.fillRect(item.x, item.y, item.width, item.height);
                
                // Draw item icons
                ctx.fillStyle = 'white';
                if (item.type === ITEM_TYPES.TRIPLE_SHOT) {
                    // Triple shot icon (3 bullets)
                    ctx.fillRect(item.x + 4, item.y + 4, 8, 2);
                    ctx.fillRect(item.x + 3, item.y + 8, 10, 2);
                    ctx.fillRect(item.x + 4, item.y + 12, 8, 2);
                } else if (item.type === ITEM_TYPES.HEALTH_30) {
                    // +30 icon
                    ctx.fillRect(item.x + 6, item.y + 4, 4, 8);
                    ctx.fillRect(item.x + 4, item.y + 6, 8, 4);
                    ctx.font = '8px monospace';
                    ctx.fillText('+30', item.x + 2, item.y + 14);
                } else {
                    // Full health icon (heart)
                    ctx.beginPath();
                    ctx.moveTo(item.x + 8, item.y + 4);
                    ctx.bezierCurveTo(
                        item.x + 8, item.y + 1,
                        item.x + 4, item.y + 1,
                        item.x + 4, item.y + 4
                    );
                    ctx.bezierCurveTo(
                        item.x + 4, item.y + 7,
                        item.x + 8, item.y + 10,
                        item.x + 12, item.y + 7
                    );
                    ctx.bezierCurveTo(
                        item.x + 12, item.y + 4,
                        item.x + 8, item.y + 1,
                        item.x + 8, item.y + 4
                    );
                    ctx.fill();
                }
            });
            
            // Draw explosions
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            gameState.explosions.forEach(explosion => {
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                // Gradient from yellow to red
                const greenValue = Math.max(50, 200 - Math.floor(explosion.radius * 5));
                ctx.fillStyle = `rgba(255, ${greenValue}, 0, 0.7)`;
                ctx.fill();
                ctx.stroke();
            });
            
            // NEW: Draw death explosion
            if (gameState.deathExplosion.active) {
                gameState.deathExplosion.particles.forEach(p => {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
            
            // Draw triple shot indicator
            if (gameState.tripleShotActive) {
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const remainingTime = Math.ceil((gameState.tripleShotEndTime - Date.now()) / 1000);
                ctx.fillStyle = 'white';
                ctx.font = '20px monospace';
                ctx.fillText(`TRIPLE SHOT: ${remainingTime}s`, 20, canvas.height - 30);
            }
            
            // Show next item timer
            const timeUntilNextItem = Math.ceil((gameState.nextItemTime - Date.now()) / 1000);
            if (timeUntilNextItem > 0 && gameStarted) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '16px monospace';
                ctx.fillText(`Next item in: ${timeUntilNextItem}s`, canvas.width - 200, 30);
            }
        }

        // Game loop
        function gameLoop() {
            if (gameState.gameOver) {
                // Keep rendering death explosion
                if (gameState.deathExplosion.active) {
                    update();
                    render();
                    requestAnimationFrame(gameLoop);
                }
                return;
            }
            if (gameStarted) {
                update();
                render();
            }
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', e => {
            gameState.keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', e => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouse.x = e.clientX - rect.left;
            gameState.mouse.y = e.clientY - rect.top;
            
            // Calculate crosshair position relative to container
            const containerRect = container.getBoundingClientRect();
            crosshair.style.left = (e.clientX - containerRect.left) + 'px';
            crosshair.style.top = (e.clientY - containerRect.top) + 'px';
        });

        canvas.addEventListener('mousedown', () => {
            fireBullet();
        });

        // Touch aiming on canvas
        const touchToCanvasPos = (touch) => {
            const rect = canvas.getBoundingClientRect();
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        };
        const touchToContainerPos = (touch) => {
            const rect = container.getBoundingClientRect();
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        };
        canvas.addEventListener('touchstart', (e) => {
            if (!isTouch) return;
            const t = e.changedTouches[0];
            const p = touchToCanvasPos(t);
            gameState.mouse.x = p.x;
            gameState.mouse.y = p.y;
            const pc = touchToContainerPos(t);
            crosshair.style.left = pc.x + 'px';
            crosshair.style.top = pc.y + 'px';
        }, { passive: true });
        canvas.addEventListener('touchmove', (e) => {
            if (!isTouch) return;
            const t = e.changedTouches[0];
            const p = touchToCanvasPos(t);
            gameState.mouse.x = p.x;
            gameState.mouse.y = p.y;
            const pc = touchToContainerPos(t);
            crosshair.style.left = pc.x + 'px';
            crosshair.style.top = pc.y + 'px';
        }, { passive: true });

        // Add event listeners only if elements exist
        if (startButton) {
            startButton.addEventListener('click', () => {
                gameStarted = true;
                startButton.style.display = 'none';
                document.getElementById('gameNote').style.display = 'none'; // Hide note when game starts
                
                // Initialize timed item spawning (start 20 seconds after game start)
                gameState.nextItemTime = Date.now() + gameState.itemSpawnInterval;
                
                gameLoop();
            });
        }
        
        if (recallButton) {
            recallButton.addEventListener('click', () => {
                gameState.player.health = Math.min(100, gameState.player.health + 30);
                healthDisplay.textContent = Math.max(0, Math.floor(gameState.player.health));
                recallButton.style.display = 'none';
            });
        }
        
        if (restartButton) {
            restartButton.addEventListener('click', () => {
                location.reload();
            });
        }

        // Setup mobile controls if on touch device
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function setupMobileControls() {
            if (!isTouch) return;
            // Show controls
            joystick.style.display = 'block';
            fireButton.style.display = 'block';

            // Prevent default gestures that cause scrolling
            ['touchstart','touchmove','touchend','touchcancel'].forEach(evt => {
                document.body.addEventListener(evt, (e) => {
                    if (e.target === joystick || e.target === joystickKnob || e.target === fireButton || e.target === canvas) {
                        e.preventDefault();
                    }
                }, { passive: false });
            });

            const joyRadius = 50; // movement radius in px

            const getTouch = (e) => (e.changedTouches && e.changedTouches[0]) || null;
            const joyStart = (e) => {
                const t = getTouch(e); if (!t) return;
                const rect = joystick.getBoundingClientRect();
                mobile.joystickActive = true;
                mobile.joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                joyMove(e);
            };
            const joyMove = (e) => {
                if (!mobile.joystickActive) return;
                const t = getTouch(e); if (!t) return;
                const dx = t.clientX - mobile.joyCenter.x;
                const dy = t.clientY - mobile.joyCenter.y;
                const dist = Math.hypot(dx, dy);
                const clampedDist = Math.min(dist, joyRadius);
                const nx = dist ? dx / dist : 0;
                const ny = dist ? dy / dist : 0;
                mobile.joyValue.x = (clampedDist / joyRadius) * nx;
                mobile.joyValue.y = (clampedDist / joyRadius) * ny;
                // Move knob
                joystickKnob.style.marginLeft = (-30 + nx * clampedDist) + 'px';
                joystickKnob.style.marginTop = (-30 + ny * clampedDist) + 'px';
            };
            const joyEnd = () => {
                mobile.joystickActive = false;
                mobile.joyValue.x = 0; mobile.joyValue.y = 0;
                joystickKnob.style.marginLeft = '-30px';
                joystickKnob.style.marginTop = '-30px';
            };
            joystick.addEventListener('touchstart', joyStart, { passive: false });
            joystick.addEventListener('touchmove', joyMove, { passive: false });
            joystick.addEventListener('touchend', joyEnd, { passive: false });
            joystick.addEventListener('touchcancel', joyEnd, { passive: false });

            // Fire button (auto-fire while held)
            const startFiring = () => {
                if (mobile.firing) return;
                mobile.firing = true;
                fireBullet();
                mobile.fireInterval = setInterval(fireBullet, 200);
            };
            const stopFiring = () => {
                mobile.firing = false;
                if (mobile.fireInterval) {
                    clearInterval(mobile.fireInterval);
                    mobile.fireInterval = null;
                }
            };
            fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); startFiring(); }, { passive: false });
            fireButton.addEventListener('touchend', (e) => { e.preventDefault(); stopFiring(); }, { passive: false });
            fireButton.addEventListener('touchcancel', (e) => { e.preventDefault(); stopFiring(); }, { passive: false });
        }

        // Initialize mobile controls on load
        setupMobileControls();
    </script>
</body>
</html>